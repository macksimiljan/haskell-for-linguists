<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Bigrams</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Bigrams.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">ml</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Bigrams</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Bounded Alphabets</a></li><li><a href="#g:2">Bigrams</a><ul><li><a href="#g:3">Bigram extraction</a></li><li><a href="#g:4">Bigram checking</a></li></ul></li><li><a href="#g:5">N-grams</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module introduces our first notion of a grammar.  There are
 three main problems that a grammar should help us solve.</p><dl><dt>Learning</dt><dd>How could we learn a grammar from language data?</dd><dt>Parsing</dt><dd>How could we use a grammar to understand (i.e. recognize) a sentence?</dd><dt>Production</dt><dd>How could we use a grammar to construct a sentence?</dd></dl></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Bounds">Bounds</a> a</li><li class="src short"><a href="#v:makeBounded">makeBounded</a> :: [a] -&gt; [<a href="Bigrams.html#t:Bounds">Bounds</a> a]</li><li class="src short"><span class="keyword">type</span> <a href="#t:Bigram">Bigram</a> a = (<a href="Bigrams.html#t:Bounds">Bounds</a> a, <a href="Bigrams.html#t:Bounds">Bounds</a> a)</li><li class="src short"><a href="#v:text2Grams">text2Grams</a> :: [a] -&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a]</li><li class="src short"><a href="#v:text2Grams-39-">text2Grams'</a> :: [a] -&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a]</li><li class="src short"><a href="#v:isLicensed">isLicensed</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool</li><li class="src short"><a href="#v:isLicensed-39-">isLicensed'</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool</li><li class="src short"><a href="#v:isNotProhibited">isNotProhibited</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool</li><li class="src short"><a href="#v:isNotProhibited-39-">isNotProhibited'</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool</li><li class="src short"><span class="keyword">type</span> <a href="#t:NGram">NGram</a> a = [<a href="Bigrams.html#t:Bounds">Bounds</a> a]</li><li class="src short"><a href="#v:zipN">zipN</a> :: [[a]] -&gt; [[a]]</li><li class="src short"><a href="#v:textNGrams">textNGrams</a> :: Int -&gt; [a] -&gt; [<a href="Bigrams.html#t:NGram">NGram</a> a]</li><li class="src short"><a href="#v:textNGrams-39-">textNGrams'</a> :: Int -&gt; [a] -&gt; [<a href="Bigrams.html#t:NGram">NGram</a> a]</li><li class="src short"><a href="#v:licensedNGram">licensedNGram</a> :: Eq a =&gt; [<a href="Bigrams.html#t:NGram">NGram</a> a] -&gt; [a] -&gt; Bool</li></ul></div><div id="interface"><h1 id="g:1">Bounded Alphabets</h1><div class="doc"><p>We would like to specify which symbols can be at the beginning, and
 which at the end, of words.  In order to do this we <em>reify</em> the
 notion of word-beginning and word-end.  We do this by defining a
 new type (function), one which takes a type of symbols, and returns
 the type of those symbols with boundaries.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Bounds" class="def">Bounds</a> a <a href="#t:Bounds" class="selflink">#</a></p><div class="doc"><p>In order to include information about which letters may begin a
 word, and which may end a word, we include two new symbols <code>Start</code>
 and <code>Finish</code> which represent word boundaries.  Something of type
 <code><code><a href="Bigrams.html#t:Bounds">Bounds</a></code> a</code> is either itself an <code>a</code> (but written as <code><code>B</code> a</code>) or is
 a boundary symbol <code>Start</code> or <code>Finish</code>.</p></div><div class="subs instances"><p id="control.i:Bounds" class="caption collapser" onclick="toggleSection('i:Bounds')">Instances</p><div id="section.i:Bounds" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Bounds:Functor:1" class="instance expander" onclick="toggleSection('i:id:Bounds:Functor:1')"></span> Functor <a href="Bigrams.html#t:Bounds">Bounds</a></span> <a href="#t:Bounds" class="selflink">#</a></td><td class="doc"><p>As <code><a href="Bigrams.html#t:Bounds">Bounds</a></code> stores information, it can be viewed as a <code>Functor</code>.</p></td></tr><tr><td colspan="2"><div id="section.i:id:Bounds:Functor:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> b</p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> b -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a</p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Bounds:Bounded:2" class="instance expander" onclick="toggleSection('i:id:Bounds:Bounded:2')"></span> Bounded (<a href="Bigrams.html#t:Bounds">Bounds</a> a)</span> <a href="#t:Bounds" class="selflink">#</a></td><td class="doc"><p>Anything of type <code><code><a href="Bigrams.html#t:Bounds">Bounds</a></code> a</code> has an upper bound, <code>Finish</code>, and a
 lower bound, <code>Start</code>.</p></td></tr><tr><td colspan="2"><div id="section.i:id:Bounds:Bounded:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:minBound">minBound</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a</p><p class="src"><a href="#v:maxBound">maxBound</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a</p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Bounds:Eq:3" class="instance expander" onclick="toggleSection('i:id:Bounds:Eq:3')"></span> Eq a =&gt; Eq (<a href="Bigrams.html#t:Bounds">Bounds</a> a)</span> <a href="#t:Bounds" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Bounds:Eq:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Bool</p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Bool</p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Bounds:Ord:4" class="instance expander" onclick="toggleSection('i:id:Bounds:Ord:4')"></span> Ord a =&gt; Ord (<a href="Bigrams.html#t:Bounds">Bounds</a> a)</span> <a href="#t:Bounds" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Bounds:Ord:4" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Ordering</p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Bool</p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Bool</p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Bool</p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; Bool</p><p class="src"><a href="#v:max">max</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a</p><p class="src"><a href="#v:min">min</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a</p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Bounds:Show:5" class="instance expander" onclick="toggleSection('i:id:Bounds:Show:5')"></span> Show a =&gt; Show (<a href="Bigrams.html#t:Bounds">Bounds</a> a)</span> <a href="#t:Bounds" class="selflink">#</a></td><td class="doc"><p>If I were to ask Haskell to derive a <code>Show</code> instance for <code><a href="Bigrams.html#t:Bounds">Bounds</a></code>
 automatically, it would print <code><code>B</code> a</code> as &quot;B a&quot;.  I want it to
 simply ignore the <code>B</code>, so I have to tell it what to do myself.</p></td></tr><tr><td colspan="2"><div id="section.i:id:Bounds:Show:5" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: Int -&gt; <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; ShowS</p><p class="src"><a href="#v:show">show</a> :: <a href="Bigrams.html#t:Bounds">Bounds</a> a -&gt; String</p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Bigrams.html#t:Bounds">Bounds</a> a] -&gt; ShowS</p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:makeBounded" class="def">makeBounded</a> :: [a] -&gt; [<a href="Bigrams.html#t:Bounds">Bounds</a> a] <a href="#v:makeBounded" class="selflink">#</a></p><div class="doc"><p>Given a list of objects, we can bound the list by placing a
 <code>Start</code> symbol in front, a <code>Finish</code> symbol in back, and prefixing a
 <code>B</code> on all of the list items.</p></div></div><h1 id="g:2">Bigrams</h1><div class="doc"><p>A bigram grammar specifies a set of pairs of symbols.  We can
 understand a pair of symbols as specifying whether it is possible
 or not to have that pair of symbols be adjacent to one another (in
 that order) in a string.  We will investigate how to <em>learn</em> a
 bigram grammar from data, and how to <em>use</em> a bigram grammar to
 decide whether a string is grammatical or not.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Bigram" class="def">Bigram</a> a = (<a href="Bigrams.html#t:Bounds">Bounds</a> a, <a href="Bigrams.html#t:Bounds">Bounds</a> a) <a href="#t:Bigram" class="selflink">#</a></p><div class="doc"><p>A Bigram is just a pair of Bounded items.  We introduce this
 definition as a <em>type synonym</em>.  A type synonym does not define
 anything new, it just introduces an abbreviation for an already
 existing type.</p></div></div><h2 id="g:3">Bigram extraction</h2><div class="doc"><p>The problem of grammar learning in the context of bigrams is very
 straightforward.  The problem is, in brief, obtaining a smallest
 bigram grammar that licenses all words in a corpus.  A grammar is
 <em>smaller</em> than another just in case it licenses a subset of the
 other's words.</p><p>There are two natural ideas that we can employ to define the same
 learning algorithm.</p></div><div class="top"><p class="src"><a id="v:text2Grams" class="def">text2Grams</a> :: [a] -&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] <a href="#v:text2Grams" class="selflink">#</a></p><div class="doc"><p>The first idea begins with the observation that the bigrams which
 occur in a given word are exactly those which obtain if we pair up
 each symbol with the symbol which follows it.  We achieve this by
 aligining two copies of the same list, and then shifting one back
 by one symbol.</p></div></div><div class="top"><p class="src"><a id="v:text2Grams-39-" class="def">text2Grams'</a> :: [a] -&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] <a href="#v:text2Grams-39-" class="selflink">#</a></p><div class="doc"><p>The second idea is more algorithmic in nature: it is that the way
 of determining which bigrams occur in a word is to record each pair
 of symbols in the word.</p></div></div><h2 id="g:4">Bigram checking</h2><div class="doc"><p>We can use (bigram) grammars as <em>classifiers</em>; as ways of grouping
 the objects we are talking about (here: strings) into distinct
 <em>classes</em>.  The most common classes in linguistic contexts are
 <em>grammatical</em> and <em>ungrammatical</em> (or equivalently <em>good</em>-<em>bad</em>,
 <em>acceptable</em>-<em>unacceptable</em>, or any other 2-way classification).
 This, i.e. when we are attempting to decide whether an object
 belongs to one of a set of two classes, is commonly called the
 <strong>recognition problem</strong> for a grammar.</p><p>We think of a bigram grammar as specifying the set of <em>allowed</em>
 bigrams.  Abstractly, to solve the recognition problem for bigram
 grammars, we want to verify that all bigrams in a string are
 allowed by the grammar.</p></div><div class="top"><p class="src"><a id="v:isLicensed" class="def">isLicensed</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool <a href="#v:isLicensed" class="selflink">#</a></p><div class="doc"><p>An intuitive way of approaching a solution to the recognition
 problem for bigram grammars is to simply collect all bigrams in a
 string, and then to verify that they are allowed by the grammar.
 This approach allows us to reuse our previous algorithms for
 collecting bigrams.</p></div></div><div class="top"><p class="src"><a id="v:isLicensed-39-" class="def">isLicensed'</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool <a href="#v:isLicensed-39-" class="selflink">#</a></p><div class="doc"><p>An alternative is to walk through the string one letter at a
 time, and verify that the subsequent letter is a possible
 next-letter according to the grammar.</p></div></div><div class="doc"><p>Alternatively, we may think of a bigram grammar as specifying the
 <em>prohibited</em> bigrams (and thus as specifying the permitted ones
 indirectly as &quot;everything else&quot;).  Again, the general approach to
 checking that a sentence is not prohibited is to verify that none
 of its bigrams are illegal.</p></div><div class="top"><p class="src"><a id="v:isNotProhibited" class="def">isNotProhibited</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool <a href="#v:isNotProhibited" class="selflink">#</a></p><div class="doc"><p>The simplest way to implement this is to simply write down what
 we want to say; first we collect the bigrams in the word, and then
 we verify that none of them are prohibited by the grammar.</p></div></div><div class="top"><p class="src"><a id="v:isNotProhibited-39-" class="def">isNotProhibited'</a> :: Eq a =&gt; [<a href="Bigrams.html#t:Bigram">Bigram</a> a] -&gt; [a] -&gt; Bool <a href="#v:isNotProhibited-39-" class="selflink">#</a></p><div class="doc"><p>An alternative is to walk through the string letter by letter,
 each time verifying that the next letter is not an illegal one
 according to the grammar.</p></div></div><h1 id="g:5">N-grams</h1><div class="doc"><p>Generalizing from the case of bigrams, we see that we could just as
 easily look at <em>trigrams</em>, or <em>4-grams</em>, or ...  While we could
 implement types and functions for each kind of <em>n-gram</em>, these
 would invariably be doing &quot;the same thing&quot;, and we would miss out
 on a clean statement of the underlying generalization.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:NGram" class="def">NGram</a> a = [<a href="Bigrams.html#t:Bounds">Bounds</a> a] <a href="#t:NGram" class="selflink">#</a></p><div class="doc"><p>An n-gram is a list of Bounded items of length <code>n</code>.  A 2-gram is
 a list of length 2, which is isomorphic to a pair (i.e. to a
 <code><a href="Bigrams.html#t:Bigram">Bigram</a></code>).</p></div></div><div class="top"><p class="src"><a id="v:zipN" class="def">zipN</a> :: [[a]] -&gt; [[a]] <a href="#v:zipN" class="selflink">#</a></p><div class="doc"><p>We would like to take the list of heads of each sentence as an
 <em>n-gram</em>, and then continue looking for n-grams amongs the list of
 tails of each sentence.  There is some minor complication in that
 we need to know when we have run out of elements of a list.  We
 achieve this by using a <em>safe</em> version of the <code>head</code> operation,
 which returns <code>Nothing</code> if the list in question is empty.  Then we
 can check if <code>Nothing</code> is in the list of heads we have just
 collected.  If it is, we know that one of the lists is empty, and
 so we should stop trying to zip them together.  Otherwise, we carry
 on.</p></div></div><div class="top"><p class="src"><a id="v:textNGrams" class="def">textNGrams</a> :: Int -&gt; [a] -&gt; [<a href="Bigrams.html#t:NGram">NGram</a> a] <a href="#v:textNGrams" class="selflink">#</a></p><div class="doc"><p>The essential idea is that we want to zip together <code>n</code> copies of
 the input sentence, each one shifted one symbol back.  (This is
 thus a generalization of the <code>text2Grams</code> function.)  We do this by
 <code>iterate</code>ing the <code>tail</code> operation over the input list.  This
 creates a sequence (list) of copies of the input list, each with
 one less element than the one before.  We want just <code>n</code> copies,
 however, where <code>n</code> is the dimension of the n-gram we want to
 compute.  We thus <code>take</code> the first <code>n</code> copies of the input list.
 (If <code>n</code> is greater than the length of the input list, we will get
 an error as <code>tail</code> will be applied to an empty list.)  Then we can
 simply call <code>zipN</code> to take care of the rest.</p></div></div><div class="top"><p class="src"><a id="v:textNGrams-39-" class="def">textNGrams'</a> :: Int -&gt; [a] -&gt; [<a href="Bigrams.html#t:NGram">NGram</a> a] <a href="#v:textNGrams-39-" class="selflink">#</a></p><div class="doc"><p>Alternatively, we can simply walk through the list, each time
 taking the next <code>n</code> segments as an n-gram.</p></div></div><div class="top"><p class="src"><a id="v:licensedNGram" class="def">licensedNGram</a> :: Eq a =&gt; [<a href="Bigrams.html#t:NGram">NGram</a> a] -&gt; [a] -&gt; Bool <a href="#v:licensedNGram" class="selflink">#</a></p><div class="doc"><p>Checking whether a sentence is licensed by an n-gram grammar then
 proceeds exactly as in the bigram case, except that we need to
 determine what the <code>n</code> in question is.  We can do this by looking
 at how long the n-grams of the grammar are.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>